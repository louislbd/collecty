<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="HTTP client for embedded devices"><title>reqwless - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="reqwless" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../reqwless/index.html">reqwless</a><span class="version">0.13.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">reqwless</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/reqwless/lib.rs.html#1-142">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="http-client-for-embedded-devices"><a class="doc-anchor" href="#http-client-for-embedded-devices">§</a>HTTP client for embedded devices</h2>
<p><a href="https://github.com/drogue-iot/reqwless/actions/workflows/ci.yaml"><img src="https://github.com/drogue-iot/reqwless/actions/workflows/ci.yaml/badge.svg" alt="CI" /></a>
<a href="https://crates.io/crates/reqwless"><img src="https://img.shields.io/crates/v/reqwless.svg" alt="crates.io" /></a>
<a href="https://docs.rs/reqwless"><img src="https://docs.rs/reqwless/badge.svg" alt="docs.rs" /></a>
<a href="https://matrix.to/#/#drogue-iot:matrix.org"><img src="https://img.shields.io/matrix/drogue-iot:matrix.org" alt="Matrix" /></a></p>
<p>The <code>reqwless</code> crate implements an HTTP client that can be used in <code>no_std</code> environment, with any transport that implements the
traits from the <code>embedded-io</code> crate. No alloc or std lib required!</p>
<p>It offers two sets of APIs:</p>
<ul>
<li>A low-level <code>request</code> API which allows you to construct HTTP requests and write them to a <code>embedded-io</code> transport.</li>
<li>A higher level <code>client</code> API which uses the <code>embedded-nal-async</code> (+ optional <code>embedded-tls</code> / <code>esp-mbedtls</code>) crates to establish TCP + TLS connections.</li>
</ul>
<h3 id="example"><a class="doc-anchor" href="#example">§</a>example</h3>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>url = <span class="macro">format!</span>(<span class="string">"http://localhost"</span>, addr.port());
<span class="kw">let </span><span class="kw-2">mut </span>client = HttpClient::new(TokioTcp, StaticDns); <span class="comment">// Types implementing embedded-nal-async
</span><span class="kw">let </span><span class="kw-2">mut </span>rx_buf = [<span class="number">0</span>; <span class="number">4096</span>];
<span class="kw">let </span>response = client
    .request(Method::POST, <span class="kw-2">&amp;</span>url)
    .<span class="kw">await
    </span>.unwrap()
    .body(<span class="string">b"PING"</span>)
    .content_type(ContentType::TextPlain)
    .send(<span class="kw-2">&amp;mut </span>rx_buf)
    .<span class="kw">await
    </span>.unwrap();</code></pre></div>
<p>The client is still lacking many features, but can perform basic HTTP GET/PUT/POST/DELETE requests with payloads. However, not all content types and status codes are implemented, and are added on a need basis.  For TLS, it uses either <code>embedded-tls</code> or <code>esp-mbedtls</code> as the transport.</p>
<p>NOTE: TLS verification is not supported in no_std environments for <code>embedded-tls</code>.</p>
<p>If you are missing a feature or would like an improvement, please raise an issue or a PR.</p>
<h3 id="tls-12-13-and-supported-cipher-suites"><a class="doc-anchor" href="#tls-12-13-and-supported-cipher-suites">§</a>TLS 1.2*, 1.3 and Supported Cipher Suites</h3>
<p><code>reqwless</code> uses <code>embedded-tls</code> or <code>esp-mbedtls</code> to establish secure TLS connections for <code>https://..</code> urls.</p>
<p>*TLS 1.2 is only supported with <code>esp-mbedtls</code></p>
<p>:warning: Note that both features cannot be used together and will cause a compilation error.</p>
<p>:warning: The released version of <code>reqwless</code> does not support <code>esp-mbedtls</code>. The reason for this is that <code>esp-mbedtls</code> is not yet published to crates.io. One should specify <code>reqwless</code> as a git dependency to use <code>esp-mbedtls</code>.</p>
<h4 id="esp-mbedtls"><a class="doc-anchor" href="#esp-mbedtls">§</a>esp-mbedtls</h4>
<p><strong>Can only be used on esp32 boards</strong>
<code>esp-mbedtls</code> supports TLS 1.2 and 1.3. It uses espressif’s Rust wrapper over mbedtls, alongside optimizations such as hardware acceleration.</p>
<p>To use, you need to enable the transitive dependency of <code>esp-mbedtls</code> for your SoC.
Currently, the supported SoCs are:</p>
<ul>
<li><code>esp32</code></li>
<li><code>esp32c3</code></li>
<li><code>esp32s2</code></li>
<li><code>esp32s3</code></li>
</ul>
<p>Cargo.toml:</p>
<div class="example-wrap"><pre class="language-toml"><code>reqwless = { version = &quot;0.12.0&quot;, default-features = false, features = [&quot;esp-mbedtls&quot;, &quot;log&quot;] }
esp-mbedtls = { git = &quot;https://github.com/esp-rs/esp-mbedtls.git&quot;,  features = [&quot;esp32s3&quot;] }
</code></pre></div><!-- TODO: Update this when esp-mbedtls switches to the unified hal -->
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="doccomment">/// ... [initialization code. See esp-wifi]
</span><span class="kw">let </span>state = TcpClientState::&lt;<span class="number">1</span>, <span class="number">4096</span>, <span class="number">4096</span>&gt;::new();
<span class="kw">let </span><span class="kw-2">mut </span>tcp_client = TcpClient::new(stack, <span class="kw-2">&amp;</span>state);
<span class="kw">let </span>dns_socket = DnsSocket::new(<span class="kw-2">&amp;</span>stack);
<span class="kw">let </span><span class="kw-2">mut </span>rsa = Rsa::new(peripherals.RSA);
<span class="kw">let </span>config = TlsConfig::new(
    reqwless::TlsVersion::Tls1_3,
    reqwless::Certificates {
        ca_chain: reqwless::X509::pem(CERT.as_bytes()).ok(),
        ..Default::default()
    },
    <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span>rsa), <span class="comment">// Will use hardware acceleration
</span>);
<span class="kw">let </span><span class="kw-2">mut </span>client = HttpClient::new_with_tls(<span class="kw-2">&amp;</span>tcp_client, <span class="kw-2">&amp;</span>dns_socket, config);

<span class="kw">let </span><span class="kw-2">mut </span>request = client
    .request(reqwless::request::Method::GET, <span class="string">"https://www.google.com"</span>)
    .<span class="kw">await
    </span>.unwrap()
    .content_type(reqwless::headers::ContentType::TextPlain)
    .headers(<span class="kw-2">&amp;</span>[(<span class="string">"Host"</span>, <span class="string">"google.com"</span>)])
    .send(<span class="kw-2">&amp;mut </span>buffer)
    .<span class="kw">await
    </span>.unwrap();</code></pre></div>
<h4 id="embedded-tls"><a class="doc-anchor" href="#embedded-tls">§</a>embedded-tls</h4>
<p><code>embedded-tls</code> only supports TLS 1.3, so to establish a connection the server must have this ssl protocol enabled.</p>
<p>An addition to the tls version requirement, there is also a negotiation of supported algorithms during the establishing phase of the secure communication between the client and server.
By default, the set of supported algorithms in <code>embedded-tls</code> is limited to algorithms that can run entirely on the stack.
To test whether the server supports this limited set of algorithm, try and test the server using the following <code>openssl</code> command:</p>
<div class="example-wrap"><pre class="language-bash"><code>openssl s_client -tls1_3 -ciphersuites TLS_AES_128_GCM_SHA256 -sigalgs &quot;ECDSA+SHA256:ECDSA+SHA384:ed25519&quot; -connect hostname:443
</code></pre></div>
<p>If the server successfully replies to the client hello then the enabled tls version and algorithms on the server should be ok.
If the command fails, then try and run without the limited set of signature algorithms</p>
<div class="example-wrap"><pre class="language-bash"><code>openssl s_client -tls1_3 -ciphersuites TLS_AES_128_GCM_SHA256 -connect hostname:443
</code></pre></div>
<p>If this works, then there are two options. Either enable the signature algorithms on the server by changing the private key from RSA to ECDSA or ed25519, or enable RSA keys on the client by specifying the <code>alloc</code> feature.
This enables <code>alloc</code> on <code>embedded-tls</code> which in turn enables RSA signature algorithms.</p>
<h2 id="minimum-supported-rust-version-msrv"><a class="doc-anchor" href="#minimum-supported-rust-version-msrv">§</a>Minimum supported Rust version (MSRV)</h2>
<p><code>reqwless</code> can compile on stable Rust 1.77 and up.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="client/index.html" title="mod reqwless::client">client</a></div></li><li><div class="item-name"><a class="mod" href="headers/index.html" title="mod reqwless::headers">headers</a></div></li><li><div class="item-name"><a class="mod" href="request/index.html" title="mod reqwless::request">request</a></div></li><li><div class="item-name"><a class="mod" href="response/index.html" title="mod reqwless::response">response</a></div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum reqwless::Error">Error</a></div><div class="desc docblock-short">Errors that can be returned by this library.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.TryBufRead.html" title="trait reqwless::TryBufRead">TryBuf<wbr>Read</a></div><div class="desc docblock-short">Trait for types that may optionally implement <a href="../embedded_io_async/trait.BufRead.html" title="trait embedded_io_async::BufRead"><code>embedded_io_async::BufRead</code></a></div></li></ul></section></div></main></body></html>