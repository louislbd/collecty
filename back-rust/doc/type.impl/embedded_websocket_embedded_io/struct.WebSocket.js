(function() {
    var type_impls = Object.fromEntries([["embedded_websocket_embedded_io",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-WebSocket%3CT,+Client%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/embedded_websocket_embedded_io/lib.rs.html#473-571\">source</a><a href=\"#impl-WebSocket%3CT,+Client%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"struct\" href=\"embedded_websocket_embedded_io/struct.WebSocket.html\" title=\"struct embedded_websocket_embedded_io::WebSocket\">WebSocket</a>&lt;T, <a class=\"enum\" href=\"embedded_websocket_embedded_io/enum.Client.html\" title=\"enum embedded_websocket_embedded_io::Client\">Client</a>&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"rand_core/trait.RngCore.html\" title=\"trait rand_core::RngCore\">RngCore</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.client_connect\" class=\"method\"><a class=\"src rightside\" href=\"src/embedded_websocket_embedded_io/lib.rs.html#510-526\">source</a><h4 class=\"code-header\">pub fn <a href=\"embedded_websocket_embedded_io/struct.WebSocket.html#tymethod.client_connect\" class=\"fn\">client_connect</a>(\n    &amp;mut self,\n    websocket_options: &amp;<a class=\"struct\" href=\"embedded_websocket_embedded_io/struct.WebSocketOptions.html\" title=\"struct embedded_websocket_embedded_io::WebSocketOptions\">WebSocketOptions</a>&lt;'_&gt;,\n    to: &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.u8.html\">u8</a>],\n) -&gt; <a class=\"type\" href=\"embedded_websocket_embedded_io/type.Result.html\" title=\"type embedded_websocket_embedded_io::Result\">Result</a>&lt;(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.usize.html\">usize</a>, <a class=\"type\" href=\"embedded_websocket_embedded_io/type.WebSocketKey.html\" title=\"type embedded_websocket_embedded_io::WebSocketKey\">WebSocketKey</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Used by the client to initiate a websocket opening handshake</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>embedded_websocket <span class=\"kw\">as </span>ws;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buffer: [u8; <span class=\"number\">2000</span>] = [<span class=\"number\">0</span>; <span class=\"number\">2000</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ws_client = ws::WebSocketClient::new_client(rand::thread_rng());\n<span class=\"kw\">let </span>sub_protocols = [<span class=\"string\">\"chat\"</span>, <span class=\"string\">\"superchat\"</span>];\n<span class=\"kw\">let </span>websocket_options = ws::WebSocketOptions {\n    path: <span class=\"string\">\"/chat\"</span>,\n    host: <span class=\"string\">\"localhost\"</span>,\n    origin: <span class=\"string\">\"http://localhost\"</span>,\n    sub_protocols: <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>sub_protocols),\n    additional_headers: <span class=\"prelude-val\">None</span>,\n};\n\n<span class=\"kw\">let </span>(len, web_socket_key) = ws_client.client_connect(<span class=\"kw-2\">&amp;</span>websocket_options, <span class=\"kw-2\">&amp;mut </span>buffer).unwrap();\n\n<span class=\"kw\">let </span>actual_http = std::str::from_utf8(<span class=\"kw-2\">&amp;</span>buffer[..len]).unwrap();\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>expected_http = String::new();\nexpected_http.push_str(<span class=\"string\">\"GET /chat HTTP/1.1\\r\\nHost: localhost\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Key: \"</span>);\nexpected_http.push_str(web_socket_key.as_str());\nexpected_http.push_str(<span class=\"string\">\"\\r\\nOrigin: http://localhost\\r\\nSec-WebSocket-Protocol: chat, superchat\\r\\nSec-WebSocket-Version: 13\\r\\n\\r\\n\"</span>);\n<span class=\"macro\">assert_eq!</span>(expected_http.as_str(), actual_http);</code></pre></div>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">§</a>Errors</h5>\n<ul>\n<li>The http response is built with a stack allocated 1KB buffer and will return an\n<code>Unknown</code> error if that buffer is too small. This would happen is the user supplied too many\nadditional headers or the sub-protocol string is too large</li>\n<li>This function can return an <code>Utf8Error</code> if there was an error with the generation of the\naccept string. This should be impossible but an error is preferable to a panic</li>\n<li>Returns <code>WebsocketAlreadyOpen</code> if called on a websocket that is already open</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.client_accept\" class=\"method\"><a class=\"src rightside\" href=\"src/embedded_websocket_embedded_io/lib.rs.html#550-570\">source</a><h4 class=\"code-header\">pub fn <a href=\"embedded_websocket_embedded_io/struct.WebSocket.html#tymethod.client_accept\" class=\"fn\">client_accept</a>(\n    &amp;mut self,\n    sec_websocket_key: &amp;<a class=\"type\" href=\"embedded_websocket_embedded_io/type.WebSocketKey.html\" title=\"type embedded_websocket_embedded_io::WebSocketKey\">WebSocketKey</a>,\n    from: &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.u8.html\">u8</a>],\n) -&gt; <a class=\"type\" href=\"embedded_websocket_embedded_io/type.Result.html\" title=\"type embedded_websocket_embedded_io::Result\">Result</a>&lt;(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.usize.html\">usize</a>, <a class=\"enum\" href=\"https://doc.rust-lang.org/1.82.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"type\" href=\"embedded_websocket_embedded_io/type.WebSocketSubProtocol.html\" title=\"type embedded_websocket_embedded_io::WebSocketSubProtocol\">WebSocketSubProtocol</a>&gt;)&gt;</h4></section></summary><div class=\"docblock\"><p>Used by a websocket client for checking the server response to an opening handshake\n(sent using the client_connect function). If the client requested one or more sub protocols\nthe server will choose one (or none) and you get that in the result</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>embedded_websocket <span class=\"kw\">as </span>ws;\n<span class=\"kw\">use </span>core::str::FromStr;\n<span class=\"kw\">use </span>heapless::String;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ws_client = ws::WebSocketClient::new_client(rand::thread_rng());\n<span class=\"kw\">let </span>ws_key: ws::WebSocketKey = String::from_str(<span class=\"string\">\"Z7OY1UwHOx/nkSz38kfPwg==\"</span>).unwrap();\n<span class=\"kw\">let </span>server_response_html = <span class=\"string\">\"HTTP/1.1 101 Switching Protocols\\r\\nConnection: Upgrade\\r\\nUpgrade: websocket\\r\\nSec-WebSocket-Protocol: chat\\r\\nSec-WebSocket-Accept: ptPnPeDOTo6khJlzmLhOZSh2tAY=\\r\\n\\r\\n\"</span>;    <span class=\"doccomment\">///\n</span><span class=\"kw\">let </span>(len, sub_protocol) = ws_client.client_accept(<span class=\"kw-2\">&amp;</span>ws_key, server_response_html.as_bytes())\n    .unwrap();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">159</span>, len);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"chat\"</span>, sub_protocol.unwrap());</code></pre></div>\n<h5 id=\"errors-1\"><a class=\"doc-anchor\" href=\"#errors-1\">§</a>Errors</h5>\n<ul>\n<li>Returns <code>HttpResponseCodeInvalid</code> if the HTTP response code is not <code>101 Switching Protocols</code></li>\n<li>Returns <code>AcceptStringInvalid</code> if the web server failed to return a valid accept string</li>\n<li>Returns <code>HttpHeader(Version)</code> or some other varient if the HTTP response is not well formed</li>\n<li>Returns <code>WebsocketAlreadyOpen</code> if called on a websocket that is already open</li>\n</ul>\n</div></details></div></details>",0,"embedded_websocket_embedded_io::WebSocketClient"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-WebSocket%3CT,+Server%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/embedded_websocket_embedded_io/lib.rs.html#413-471\">source</a><a href=\"#impl-WebSocket%3CT,+Server%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"struct\" href=\"embedded_websocket_embedded_io/struct.WebSocket.html\" title=\"struct embedded_websocket_embedded_io::WebSocket\">WebSocket</a>&lt;T, <a class=\"enum\" href=\"embedded_websocket_embedded_io/enum.Server.html\" title=\"enum embedded_websocket_embedded_io::Server\">Server</a>&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"rand_core/trait.RngCore.html\" title=\"trait rand_core::RngCore\">RngCore</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.server_accept\" class=\"method\"><a class=\"src rightside\" href=\"src/embedded_websocket_embedded_io/lib.rs.html#449-470\">source</a><h4 class=\"code-header\">pub fn <a href=\"embedded_websocket_embedded_io/struct.WebSocket.html#tymethod.server_accept\" class=\"fn\">server_accept</a>(\n    &amp;mut self,\n    sec_websocket_key: &amp;<a class=\"type\" href=\"embedded_websocket_embedded_io/type.WebSocketKey.html\" title=\"type embedded_websocket_embedded_io::WebSocketKey\">WebSocketKey</a>,\n    sec_websocket_protocol: <a class=\"enum\" href=\"https://doc.rust-lang.org/1.82.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;<a class=\"type\" href=\"embedded_websocket_embedded_io/type.WebSocketSubProtocol.html\" title=\"type embedded_websocket_embedded_io::WebSocketSubProtocol\">WebSocketSubProtocol</a>&gt;,\n    to: &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.u8.html\">u8</a>],\n) -&gt; <a class=\"type\" href=\"embedded_websocket_embedded_io/type.Result.html\" title=\"type embedded_websocket_embedded_io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Used by the server to accept an incoming client connection and build a websocket upgrade\nhttp response string. The client http header should be read with the <code>read_http_header</code>\nfunction and the result should be passed to this function.\nWebsocket state will change from None -&gt; Open if successful, otherwise None -&gt; Aborted</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>embedded_websocket <span class=\"kw\">as </span>ws;\n<span class=\"kw\">use </span>core::str::FromStr;\n<span class=\"kw\">use </span>heapless::String;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buffer: [u8; <span class=\"number\">1000</span>] = [<span class=\"number\">0</span>; <span class=\"number\">1000</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ws_server = ws::WebSocketServer::new_server();\n<span class=\"kw\">let </span>ws_key: ws::WebSocketKey = String::from_str(<span class=\"string\">\"Z7OY1UwHOx/nkSz38kfPwg==\"</span>).unwrap();\n<span class=\"kw\">let </span>sub_protocol: ws::WebSocketSubProtocol = String::from_str(<span class=\"string\">\"chat\"</span>).unwrap();\n<span class=\"kw\">let </span>len = ws_server\n    .server_accept(<span class=\"kw-2\">&amp;</span>ws_key, <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>sub_protocol), <span class=\"kw-2\">&amp;mut </span>buffer)\n    .unwrap();\n<span class=\"kw\">let </span>response = std::str::from_utf8(<span class=\"kw-2\">&amp;</span>buffer[..len]).unwrap();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"HTTP/1.1 101 Switching Protocols\\r\\nConnection: Upgrade\\r\\nUpgrade: websocket\\r\\nSec-WebSocket-Protocol: chat\\r\\nSec-WebSocket-Accept: ptPnPeDOTo6khJlzmLhOZSh2tAY=\\r\\n\\r\\n\"</span>, response);</code></pre></div>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">§</a>Errors</h5>\n<p>There should be no way for a user provided input to return the errors listed below as the\ninput is already constrained.</p>\n<ul>\n<li>The http response is built with a stack allocated 1KB buffer and it <em>should be impossible</em>\nfor it to return an  <code>Unknown</code> error if that buffer is too small. However, this is better\nthan a panic and it will do so if the response header is too large to fit in the buffer</li>\n<li>This function can return an <code>Utf8Error</code> if there was an error with the generation of the\naccept string. This should also be impossible but an error is preferable to a panic</li>\n<li>Returns <code>WebsocketAlreadyOpen</code> if called on a websocket that is already open</li>\n</ul>\n</div></details></div></details>",0,"embedded_websocket_embedded_io::WebSocketServer"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-WebSocket%3CT,+Type%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/embedded_websocket_embedded_io/lib.rs.html#361-411\">source</a><a href=\"#impl-WebSocket%3CT,+Type%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, Type&gt; <a class=\"struct\" href=\"embedded_websocket_embedded_io/struct.WebSocket.html\" title=\"struct embedded_websocket_embedded_io::WebSocket\">WebSocket</a>&lt;T, Type&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"rand_core/trait.RngCore.html\" title=\"trait rand_core::RngCore\">RngCore</a>,\n    Type: <a class=\"trait\" href=\"embedded_websocket_embedded_io/trait.WebSocketType.html\" title=\"trait embedded_websocket_embedded_io::WebSocketType\">WebSocketType</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_client\" class=\"method\"><a class=\"src rightside\" href=\"src/embedded_websocket_embedded_io/lib.rs.html#376-386\">source</a><h4 class=\"code-header\">pub fn <a href=\"embedded_websocket_embedded_io/struct.WebSocket.html#tymethod.new_client\" class=\"fn\">new_client</a>(rng: T) -&gt; <a class=\"type\" href=\"embedded_websocket_embedded_io/type.WebSocketClient.html\" title=\"type embedded_websocket_embedded_io::WebSocketClient\">WebSocketClient</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new websocket client by passing in a required random number generator</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>embedded_websocket <span class=\"kw\">as </span>ws;\n<span class=\"kw\">use </span>rand;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ws_client = ws::WebSocketClient::new_client(rand::thread_rng());\n\n<span class=\"macro\">assert_eq!</span>(ws::WebSocketState::None, ws_client.state);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_server\" class=\"method\"><a class=\"src rightside\" href=\"src/embedded_websocket_embedded_io/lib.rs.html#399-410\">source</a><h4 class=\"code-header\">pub fn <a href=\"embedded_websocket_embedded_io/struct.WebSocket.html#tymethod.new_server\" class=\"fn\">new_server</a>() -&gt; <a class=\"type\" href=\"embedded_websocket_embedded_io/type.WebSocketServer.html\" title=\"type embedded_websocket_embedded_io::WebSocketServer\">WebSocketServer</a></h4></section></summary><div class=\"docblock\"><p>Creates a new websocket server. Note that you must use the <code>WebSocketServer</code> type and\nnot the generic <code>WebSocket</code> type for this call or you will get a <code>'type annotations needed'</code>\ncompilation error.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>embedded_websocket <span class=\"kw\">as </span>ws;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ws_server = ws::WebSocketServer::new_server();\n\n<span class=\"macro\">assert_eq!</span>(ws::WebSocketState::None, ws_server.state);</code></pre></div>\n</div></details></div></details>",0,"embedded_websocket_embedded_io::WebSocketServer","embedded_websocket_embedded_io::WebSocketClient"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-WebSocket%3CT,+Type%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/embedded_websocket_embedded_io/lib.rs.html#573-834\">source</a><a href=\"#impl-WebSocket%3CT,+Type%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, Type&gt; <a class=\"struct\" href=\"embedded_websocket_embedded_io/struct.WebSocket.html\" title=\"struct embedded_websocket_embedded_io::WebSocket\">WebSocket</a>&lt;T, Type&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"rand_core/trait.RngCore.html\" title=\"trait rand_core::RngCore\">RngCore</a>,\n    Type: <a class=\"trait\" href=\"embedded_websocket_embedded_io/trait.WebSocketType.html\" title=\"trait embedded_websocket_embedded_io::WebSocketType\">WebSocketType</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.read\" class=\"method\"><a class=\"src rightside\" href=\"src/embedded_websocket_embedded_io/lib.rs.html#617-648\">source</a><h4 class=\"code-header\">pub fn <a href=\"embedded_websocket_embedded_io/struct.WebSocket.html#tymethod.read\" class=\"fn\">read</a>(\n    &amp;mut self,\n    from: &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.u8.html\">u8</a>],\n    to: &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.u8.html\">u8</a>],\n) -&gt; <a class=\"type\" href=\"embedded_websocket_embedded_io/type.Result.html\" title=\"type embedded_websocket_embedded_io::Result\">Result</a>&lt;<a class=\"struct\" href=\"embedded_websocket_embedded_io/struct.WebSocketReadResult.html\" title=\"struct embedded_websocket_embedded_io::WebSocketReadResult\">WebSocketReadResult</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Reads the payload from a websocket frame in buffer <code>from</code> into a buffer <code>to</code> and returns\nmetadata about the frame. Since this function is designed to be called in a memory\nconstrained system we may not read the entire payload in one go. In each of the scenarios\nbelow the <code>read_result.end_of_message</code> flag would be <code>false</code>:</p>\n<ul>\n<li>The payload is fragmented into multiple websocket frames (as per the websocket spec)</li>\n<li>The <code>from</code> buffer does not hold the entire websocket frame. For example if only part of\nthe frame was read or if the <code>from</code> buffer is too small to hold an entire websocket frame</li>\n<li>The <code>to</code> buffer is too small to hold the entire websocket frame payload</li>\n</ul>\n<p>If the function returns <code>read_result.end_of_message</code> <code>false</code> then the next\ncall to the function should not include data that has already been passed into the function.\nThe websocket <em>remembers</em> the websocket frame header and is able to process the rest of the\npayload correctly. If the <code>from</code> buffer contains multiple websocket frames then only one of\nthem will be returned at a time and the user must make multiple calls to the function by\ntaking note of <code>read_result.len_from</code> which tells you how many bytes were read from the\n<code>from</code> buffer</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>embedded_websocket <span class=\"kw\">as </span>ws;\n<span class=\"comment\">//                    h   e   l   l   o\n</span><span class=\"kw\">let </span>buffer1 = [<span class=\"number\">129</span>,<span class=\"number\">5</span>,<span class=\"number\">104</span>,<span class=\"number\">101</span>,<span class=\"number\">108</span>,<span class=\"number\">108</span>,<span class=\"number\">111</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buffer2: [u8; <span class=\"number\">128</span>] = [<span class=\"number\">0</span>; <span class=\"number\">128</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ws_client = ws::WebSocketClient::new_client(rand::thread_rng());\nws_client.state = ws::WebSocketState::Open; <span class=\"comment\">// skip the opening handshake\n</span><span class=\"kw\">let </span>ws_result = ws_client.read(<span class=\"kw-2\">&amp;</span>buffer1, <span class=\"kw-2\">&amp;mut </span>buffer2).unwrap();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"hello\"</span>.as_bytes(), <span class=\"kw-2\">&amp;</span>buffer2[..ws_result.len_to]);</code></pre></div>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">§</a>Errors</h5>\n<ul>\n<li>Returns <code>WebSocketNotOpen</code> when the websocket is not open when this function is called</li>\n<li>Returns <code>InvalidOpCode</code> if the websocket frame contains an invalid opcode</li>\n<li>Returns <code>UnexpectedContinuationFrame</code> if we receive a continuation frame without first\nreceiving a non-continuation frame with an opcode describing the payload</li>\n<li>Returns <code>ReadFrameIncomplete</code> if the <code>from</code> buffer does not contain a full websocket\nheader (typically 2-14 bytes depending on the payload)</li>\n<li>Returns <code>InvalidFrameLength</code> if the frame length cannot be decoded</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write\" class=\"method\"><a class=\"src rightside\" href=\"src/embedded_websocket_embedded_io/lib.rs.html#676-696\">source</a><h4 class=\"code-header\">pub fn <a href=\"embedded_websocket_embedded_io/struct.WebSocket.html#tymethod.write\" class=\"fn\">write</a>(\n    &amp;mut self,\n    message_type: <a class=\"enum\" href=\"embedded_websocket_embedded_io/enum.WebSocketSendMessageType.html\" title=\"enum embedded_websocket_embedded_io::WebSocketSendMessageType\">WebSocketSendMessageType</a>,\n    end_of_message: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.bool.html\">bool</a>,\n    from: &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.u8.html\">u8</a>],\n    to: &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.u8.html\">u8</a>],\n) -&gt; <a class=\"type\" href=\"embedded_websocket_embedded_io/type.Result.html\" title=\"type embedded_websocket_embedded_io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Writes the payload in <code>from</code> to a websocket frame in <code>to</code></p>\n<ul>\n<li>message_type - The type of message to send: Text, Binary or CloseReply</li>\n<li>end_of_message - False to fragment a frame into multiple smaller frames. The last frame\nshould set this to true</li>\n<li>from - The buffer containing the payload to encode</li>\n<li>to - The the buffer to save the websocket encoded payload to.\nReturns the number of bytes written to the <code>to</code> buffer</li>\n</ul>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>embedded_websocket <span class=\"kw\">as </span>ws;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buffer: [u8; <span class=\"number\">1000</span>] = [<span class=\"number\">0</span>; <span class=\"number\">1000</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ws_server = ws::WebSocketServer::new_server();\nws_server.state = ws::WebSocketState::Open; <span class=\"comment\">// skip the opening handshake\n</span><span class=\"kw\">let </span>len = ws_server.write(ws::WebSocketSendMessageType::Text, <span class=\"bool-val\">true</span>, <span class=\"string\">\"hello\"</span>.as_bytes(),\n    <span class=\"kw-2\">&amp;mut </span>buffer).unwrap();\n\n<span class=\"comment\">//                     h   e   l   l   o\n</span><span class=\"kw\">let </span>expected = [<span class=\"number\">129</span>,<span class=\"number\">5</span>,<span class=\"number\">104</span>,<span class=\"number\">101</span>,<span class=\"number\">108</span>,<span class=\"number\">108</span>,<span class=\"number\">111</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>expected, <span class=\"kw-2\">&amp;</span>buffer[..len]);</code></pre></div>\n<h5 id=\"errors-1\"><a class=\"doc-anchor\" href=\"#errors-1\">§</a>Errors</h5>\n<ul>\n<li>Returns <code>WebSocketNotOpen</code> when the websocket is not open when this function is called</li>\n<li>Returns <code>WriteToBufferTooSmall</code> when the <code>to</code> buffer is too small to fit the websocket\nframe header (2-14 bytes) plus the payload. Consider fragmenting the messages by making\nmultiple write calls with <code>end_of_message</code> set to <code>false</code> and the final call set to <code>true</code></li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.close\" class=\"method\"><a class=\"src rightside\" href=\"src/embedded_websocket_embedded_io/lib.rs.html#705-734\">source</a><h4 class=\"code-header\">pub fn <a href=\"embedded_websocket_embedded_io/struct.WebSocket.html#tymethod.close\" class=\"fn\">close</a>(\n    &amp;mut self,\n    close_status: <a class=\"enum\" href=\"embedded_websocket_embedded_io/enum.WebSocketCloseStatusCode.html\" title=\"enum embedded_websocket_embedded_io::WebSocketCloseStatusCode\">WebSocketCloseStatusCode</a>,\n    status_description: <a class=\"enum\" href=\"https://doc.rust-lang.org/1.82.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.str.html\">str</a>&gt;,\n    to: &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.u8.html\">u8</a>],\n) -&gt; <a class=\"type\" href=\"embedded_websocket_embedded_io/type.Result.html\" title=\"type embedded_websocket_embedded_io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Initiates a close handshake.\nBoth the client and server may initiate a close handshake. If successful the function\nchanges the websocket state from Open -&gt; CloseSent</p>\n<h5 id=\"errors-2\"><a class=\"doc-anchor\" href=\"#errors-2\">§</a>Errors</h5>\n<ul>\n<li>Returns <code>WebSocketNotOpen</code> when the websocket is not open when this function is called</li>\n<li>Returns <code>WriteToBufferTooSmall</code> when the <code>to</code> buffer is too small to fit the websocket\nframe header (2-14 bytes) plus the payload. Consider sending a smaller status_description</li>\n</ul>\n</div></details></div></details>",0,"embedded_websocket_embedded_io::WebSocketServer","embedded_websocket_embedded_io::WebSocketClient"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[27832]}