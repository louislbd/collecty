<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="embedded-nal - A Network Abstraction Layer for Embedded Systems"><title>embedded_nal - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="embedded_nal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../embedded_nal/index.html">embedded_<wbr>nal</a><span class="version">0.9.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">embedded_nal</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/embedded_nal/lib.rs.html#1-15">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="embedded-nal---a-network-abstraction-layer-for-embedded-systems"><a class="doc-anchor" href="#embedded-nal---a-network-abstraction-layer-for-embedded-systems">§</a>embedded-nal - A Network Abstraction Layer for Embedded Systems</h2></div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.nb"><code>pub use <a class="mod" href="../nb/index.html" title="mod nb">nb</a>;</code></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.SharableStack.html" title="struct embedded_nal::SharableStack">Sharable<wbr>Stack</a></div><div class="desc docblock-short">Sharable wrapper for a network stack implementation.</div></li><li><div class="item-name"><a class="struct" href="struct.SharedStack.html" title="struct embedded_nal::SharedStack">Shared<wbr>Stack</a></div><div class="desc docblock-short">Single-thread shared reference to an internal network stack implementation.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.AddrType.html" title="enum embedded_nal::AddrType">Addr<wbr>Type</a></div><div class="desc docblock-short">This is the host address type to be returned by <code>gethostbyname</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.TcpErrorKind.html" title="enum embedded_nal::TcpErrorKind">TcpError<wbr>Kind</a></div><div class="desc docblock-short">Represents specific errors encountered during TCP operations.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Dns.html" title="trait embedded_nal::Dns">Dns</a></div><div class="desc docblock-short">This trait is an extension trait for <a href="crate::trait@TcpStack"><code>TcpStack</code></a> and <a href="crate::trait@UdpStack"><code>UdpStack</code></a> for dns
resolutions. It does not handle every DNS record type, but is meant as an
embedded alternative to <a href="https://doc.rust-lang.org/std/net/trait.ToSocketAddrs.html"><code>ToSocketAddrs</code></a>, and is as such meant to resolve
an ip address from a hostname, or a hostname from an ip address. This means
that it only deals in host address records <code>A</code> (IPv4) and <code>AAAA</code> (IPv6).</div></li><li><div class="item-name"><a class="trait" href="trait.TcpClientStack.html" title="trait embedded_nal::TcpClientStack">TcpClient<wbr>Stack</a></div><div class="desc docblock-short">This trait is implemented by TCP/IP stacks. You could, for example, have an implementation
which knows how to send AT commands to an ESP8266 WiFi module. You could have another implementation
which knows how to driver the Rust Standard Library’s <code>std::net</code> module. Given this trait, you can
write a portable HTTP client which can work with either implementation.</div></li><li><div class="item-name"><a class="trait" href="trait.TcpError.html" title="trait embedded_nal::TcpError">TcpError</a></div><div class="desc docblock-short">Methods to resolve errors into identifiable, actionable codes on the client side.</div></li><li><div class="item-name"><a class="trait" href="trait.TcpFullStack.html" title="trait embedded_nal::TcpFullStack">TcpFull<wbr>Stack</a></div><div class="desc docblock-short">This trait is implemented by TCP/IP stacks that expose TCP server functionality. TCP servers
may listen for connection requests to establish multiple unique TCP connections with various
clients.</div></li><li><div class="item-name"><a class="trait" href="trait.UdpClientStack.html" title="trait embedded_nal::UdpClientStack">UdpClient<wbr>Stack</a></div><div class="desc docblock-short">This trait is implemented by UDP/IP stacks. You could, for example, have
an implementation which knows how to send AT commands to an ESP8266 WiFi
module. You could have another implementation which knows how to driver the
Rust Standard Library’s <code>std::net</code> module. Given this trait, you can how
write a portable CoAP client which can work with either implementation.</div></li><li><div class="item-name"><a class="trait" href="trait.UdpFullStack.html" title="trait embedded_nal::UdpFullStack">UdpFull<wbr>Stack</a></div><div class="desc docblock-short">This trait is implemented by UDP/IP stacks.  It provides the ability to
listen for packets on a specified port and send replies.</div></li></ul></section></div></main></body></html>